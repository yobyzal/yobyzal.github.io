<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="yobyzal">
  <meta name="description" content="yobyzal的网络笔记">
  
  
  <link rel="prev" href="https://yobyzal.github.io/2019/17-iterator-pattern/" />
  <link rel="next" href="https://yobyzal.github.io/2019/15-command-pattern/" />
  <link rel="canonical" href="https://yobyzal.github.io/2019/16-interpreter-pattern/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           16 - 解释器模式 | yobyzal的网络笔记
       
  </title>
  <meta name="title" content="16 - 解释器模式 | yobyzal的网络笔记">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">
  <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/yobyzal.github.io\/"
    },
    "articleSection" : "posts",
    "name" : "16 - 解释器模式",
    "headline" : "16 - 解释器模式",
    "description" : "目录 解释器模式-Interpreter Pattern 机器人控制程序 文法规则和抽象语法树 解释器模式概述 完整解决方案 再谈Context的作用 解释器模式总结         本文整理自：https:\/\/blog.csdn.net\/lovelion\/article\/details\/17517213，在此仅作整理学习。     解释器模式-Interpreter Pattern 虽然目前计算机编程语言有好几百种，但有时候我们还是希望能用一些简单的语言来实现一些特定的操作，我们只要向计算机输入一个句子或文件，它就能够按照预先定义的文法规则来对句子或文件进行解释，从而实现相应的功能。例如提供一个简单的加法\/减法解释器，只要输入一个加法\/减法表达式，它就能够计算出表达式结果，如图18-1所示，当输入字符串表达式为“1 \x2b 2 \x2b 3 – 4 \x2b 1”时，将输出计算结果为3。\n   我们知道，像C\x2b、Java和C#等语言无法直接解释类似“1 2 \x2b 3 – 4 \x2b 1”这样的字符串（如果直接作为数值表达式时可以解释），我们必须自己定义一套文法规则来实现对这些语句的解释，即设计一个自定义语言。在实际开发中，这些简单的自定义语言可以基于现有的编程语言来设计，如果所基于的编程语言是面向对象语言，此时可以使用解释器模式来实现自定义语言。\n 机器人控制程序 Sunny软件公司欲为某玩具公司开发一套机器人控制程序，在该机器人控制程序中包含一些简单的英文控制指令，每一个指令对应一个表达式(expression)，该表达式可以是简单表达式也可以是复合表达式，每一个简单表达式由移动方向(direction)，移动方式(action)和移动距离(distance)三部分组成，其中移动方向包括上(up)、下(down)、左(left)、右(right)；移动方式包括移动(move)和快速移动(run)；移动距离为一个正整数。两个表达式之间可以通过与(and)连接，形成复合(composite)表达式。\n 用户通过对图形化的设置界面进行操作可以创建一个机器人控制指令，机器人在收到指令后将按照指令的设置进行移动，例如输入控制指令：up move 5，则“向上移动5个单位”；输入控制指令：down run 10 and left move 20，则“向下快速移动10个单位再向左移动20个单位”。\n Sunny软件公司开发人员决定自定义一个简单的语言来解释机器人控制指令，根据上述需求描述，用形式化语言来表示该简单语言的文法规则如下：\n expression ::= direction action distance | composite \/\/表达式 composite ::= expression \x27and\x27 expression \/\/复合表达式 direction ::= \x27up\x27 | \x27down\x27 | \x27left\x27 | \x27right\x27 \/\/移动方向 action ::= \x27move\x27 | \x27run\x27 \/\/移动方式 distance ::= an integer \/\/移动距离   上述语言一共定义了五条文法规则，对应五个语言单位，这些语言单位可以分为两类，一类为终结符（也称为终结符表达式），例如direction、action和distance，它们是语言的最小组成单位，不能再进行拆分；另一类为非终结符（也称为非终结符表达式），例如expression和composite，它们都是一个完整的句子，包含一系列终结符或非终结符。",
    "inLanguage" : "zh-cn",
    "author" : "yobyzal",
    "creator" : "yobyzal",
    "publisher": "yobyzal",
    "accountablePerson" : "yobyzal",
    "copyrightHolder" : "yobyzal",
    "copyrightYear" : "2019",
    "datePublished": "2019-09-25 11:34:24 \x2b0800 CST",
    "dateModified" : "2019-09-25 11:34:24 \x2b0800 CST",
    "url" : "https:\/\/yobyzal.github.io\/2019\/16-interpreter-pattern\/",
    "wordCount" : "1116",
    "keywords" : [ "设计模式", "yobyzal的网络笔记"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://yobyzal.github.io/">yobyzal的网络笔记</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://yobyzal.github.io/">yobyzal的网络笔记</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>

          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">16 - 解释器模式</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://yobyzal.github.io/" rel="author">yobyzal</a> with ♥ 
                <span class="post-time">
                on <time datetime=2019-09-25 itemprop="datePublished">September 25, 2019</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://yobyzal.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"> 设计模式 </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          <div id="toc" class="toc">
<div id="toctitle">目录</div>
<ul class="sectlevel1">
<li><a href="#_解释器模式_interpreter_pattern">解释器模式-Interpreter Pattern</a>
<ul class="sectlevel2">
<li><a href="#_机器人控制程序">机器人控制程序</a></li>
<li><a href="#_文法规则和抽象语法树">文法规则和抽象语法树</a></li>
<li><a href="#_解释器模式概述">解释器模式概述</a></li>
<li><a href="#_完整解决方案">完整解决方案</a></li>
<li><a href="#_再谈context的作用">再谈Context的作用</a></li>
<li><a href="#_解释器模式总结">解释器模式总结</a></li>
</ul>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
本文整理自：https://blog.csdn.net/lovelion/article/details/17517213，在此仅作整理学习。
</td>
</tr>
</table>
</div>
<div class="sect1">
<h2 id="_解释器模式_interpreter_pattern">解释器模式-Interpreter Pattern</h2>
<div class="sectionbody">
<div class="paragraph">
<p>虽然目前计算机编程语言有好几百种，但有时候我们还是希望能用一些简单的语言来实现一些特定的操作，我们只要向计算机输入一个句子或文件，它就能够按照预先定义的文法规则来对句子或文件进行解释，从而实现相应的功能。例如提供一个简单的加法/减法解释器，只要输入一个加法/减法表达式，它就能够计算出表达式结果，如图18-1所示，当输入字符串表达式为“1 + 2 + 3 – 4 + 1”时，将输出计算结果为3。</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/加法减法解释器示意图.jpg" alt="加法/减法解释器示意图">
</div>
</div>
<div class="paragraph">
<p>我们知道，像C+、Java和C#等语言无法直接解释类似“1 2 + 3 – 4 + 1”这样的字符串（如果直接作为数值表达式时可以解释），我们必须自己定义一套文法规则来实现对这些语句的解释，即设计一个自定义语言。在实际开发中，这些简单的自定义语言可以基于现有的编程语言来设计，如果所基于的编程语言是面向对象语言，此时可以使用解释器模式来实现自定义语言。</p>
</div>
<div class="sect2">
<h3 id="_机器人控制程序">机器人控制程序</h3>
<div class="paragraph">
<p>Sunny软件公司欲为某玩具公司开发一套机器人控制程序，在该机器人控制程序中包含一些简单的英文控制指令，每一个指令对应一个表达式(expression)，该表达式可以是简单表达式也可以是复合表达式，每一个简单表达式由移动方向(direction)，移动方式(action)和移动距离(distance)三部分组成，其中移动方向包括上(up)、下(down)、左(left)、右(right)；移动方式包括移动(move)和快速移动(run)；移动距离为一个正整数。两个表达式之间可以通过与(and)连接，形成复合(composite)表达式。</p>
</div>
<div class="paragraph">
<p>用户通过对图形化的设置界面进行操作可以创建一个机器人控制指令，机器人在收到指令后将按照指令的设置进行移动，例如输入控制指令：up move 5，则“向上移动5个单位”；输入控制指令：down  run 10 and left move 20，则“向下快速移动10个单位再向左移动20个单位”。</p>
</div>
<div class="paragraph">
<p>Sunny软件公司开发人员决定自定义一个简单的语言来解释机器人控制指令，根据上述需求描述，用形式化语言来表示该简单语言的文法规则如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>expression ::= direction action distance | composite //表达式
composite ::= expression 'and' expression //复合表达式
direction ::= 'up' | 'down' | 'left' | 'right' //移动方向
action ::= 'move' | 'run' //移动方式
distance ::= an integer //移动距离</code></pre>
</div>
</div>
<div class="paragraph">
<p>上述语言一共定义了五条文法规则，对应五个语言单位，这些语言单位可以分为两类，一类为终结符（也称为终结符表达式），例如direction、action和distance，它们是语言的最小组成单位，不能再进行拆分；另一类为非终结符（也称为非终结符表达式），例如expression和composite，它们都是一个完整的句子，包含一系列终结符或非终结符。</p>
</div>
<div class="paragraph">
<p>我们根据上述规则定义出的语言可以构成很多语句，计算机程序将根据这些语句进行某种操作。为了实现对语句的解释，可以使用解释器模式，在解释器模式中每一个文法规则都将对应一个类，扩展、改变文法以及增加新的文法规则都很方便，下面就让我们正式进入解释器模式的学习，看看使用解释器模式如何来实现对机器人控制指令的处理。</p>
</div>
</div>
<div class="sect2">
<h3 id="_文法规则和抽象语法树">文法规则和抽象语法树</h3>
<div class="paragraph">
<p><strong>解释器模式描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子</strong>。在正式分析解释器模式结构之前，我们先来学习如何表示一个语言的文法规则以及如何构造一棵抽象语法树。</p>
</div>
<div class="paragraph">
<p>在前面所提到的加法/减法解释器中，每一个输入表达式，例如“1 + 2 + 3 – 4 + 1”，都包含了三个语言单位，可以使用如下文法规则来定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>expression ::= value | operation
operation ::= expression '+' expression | expression '-'  expression
value ::= an integer //一个整数值</code></pre>
</div>
</div>
<div class="paragraph">
<p>该文法规则包含三条语句，第一条表示表达式的组成方式，其中value和operation是后面两个语言单位的定义，每一条语句所定义的字符串如operation和value称为语言构造成分或语言单位，符号“::=”表示“定义为”的意思，其左边的语言单位通过右边来进行说明和定义，语言单位对应终结符表达式和非终结符表达式。如本规则中的operation是非终结符表达式，它的组成元素仍然可以是表达式，可以进一步分解，而value是终结符表达式，它的组成元素是最基本的语言单位，不能再进行分解。</p>
</div>
<div class="paragraph">
<p>在文法规则定义中可以使用一些符号来表示不同的含义，如使用“|”表示或，使用“{”和“}”表示组合，使用“*”表示出现0次或多次等，其中使用频率最高的符号是表示“或”关系的“|”，如文法规则“boolValue ::= 0 | 1”表示终结符表达式boolValue的取值可以为0或者1。</p>
</div>
<div class="paragraph">
<p>除了使用文法规则来定义一个语言，在解释器模式中还可以通过一种称之为抽象语法树(Abstract Syntax Tree, AST)的图形方式来直观地表示语言的构成，每一棵抽象语法树对应一个语言实例，如加法/减法表达式语言中的语句“1+ 2 + 3 – 4 + 1”，可以通过如图18-2所示抽象语法树来表示：</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/抽象语法树示意图.jpg" alt="抽象语法树示意图">
</div>
</div>
<div class="paragraph">
<p>在该抽象语法树中，可以通过终结符表达式value和非终结符表达式operation组成复杂的语句，<strong>每个文法规则的语言实例都可以表示为一个抽象语法树</strong>，即每一条具体的语句都可以用类似图18-2所示的抽象语法树来表示，<strong>在图中终结符表达式类的实例作为树的叶子节点，而非终结符表达式类的实例作为非叶子节点，它们可以将终结符表达式类的实例以及包含终结符和非终结符实例的子表达式作为其子节点</strong>。抽象语法树描述了如何构成一个复杂的句子，通过对抽象语法树的分析，可以识别出语言中的终结符类和非终结符类。</p>
</div>
</div>
<div class="sect2">
<h3 id="_解释器模式概述">解释器模式概述</h3>
<div class="paragraph">
<p>解释器模式是一种使用频率相对较低但学习难度较大的设计模式，它用于描述如何使用面向对象语言构成一个简单的语言解释器。在某些情况下，为了更好地描述某一些特定类型的问题，我们可以创建一种新的语言，这种语言拥有自己的表达式和结构，即文法规则，这些问题的实例将对应为该语言中的句子。此时，可以使用解释器模式来设计这种新的语言。对解释器模式的学习能够加深我们对面向对象思想的理解，并且掌握编程语言中文法规则的解释过程。</p>
</div>
<div class="paragraph">
<p>解释器模式定义如下：</p>
</div>
<div class="quoteblock">
<blockquote>
解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。解释器模式是一种类行为型模式。
</blockquote>
</div>
<div class="paragraph">
<p>由于表达式可分为终结符表达式和非终结符表达式，因此解释器模式的结构与组合模式的结构有些类似，但在解释器模式中包含更多的组成元素，它的结构如图18-3所示：</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/解释器模式结构图.jpg" alt="解释器模式结构图">
</div>
</div>
<div class="paragraph">
<p>在解释器模式结构图中包含如下几个角色：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>AbstractExpression（抽象表达式）：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。</p>
</li>
<li>
<p>TerminalExpression（终结符表达式）：终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子。</p>
</li>
<li>
<p>NonterminalExpression（非终结符表达式）：非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。</p>
</li>
<li>
<p>Context（环境类）：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在解释器模式中，每一种终结符和非终结符都有一个具体类与之对应，正因为使用类来表示每一条文法规则，所以系统将具有较好的灵活性和可扩展性。对于所有的终结符和非终结符，我们首先需要抽象出一个公共父类，即抽象表达式类，其典型代码如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">abstract</span> <span class="type">class</span> <span class="class">AbstractExpression</span> {
    <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">void</span> interpret(<span class="predefined-type">Context</span> ctx);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>终结符表达式和非终结符表达式类都是抽象表达式类的子类，对于终结符表达式，其代码很简单，主要是对终结符元素的处理，其典型代码如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">TerminalExpression</span> <span class="directive">extends</span> AbstractExpression {
    <span class="directive">public</span> <span class="type">void</span> interpret(<span class="predefined-type">Context</span> ctx) {
        <span class="comment">//终结符表达式的解释操作</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于非终结符表达式，其代码相对比较复杂，因为可以通过非终结符将表达式组合成更加复杂的结构，对于包含两个操作元素的非终结符表达式类，其典型代码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">NonterminalExpression</span> <span class="directive">extends</span> AbstractExpression {
    <span class="directive">private</span> AbstractExpression left;
    <span class="directive">private</span> AbstractExpression right;

    <span class="directive">public</span> NonterminalExpression(AbstractExpression left,AbstractExpression right) {
        <span class="local-variable">this</span>.left=left;
        <span class="local-variable">this</span>.right=right;
    }

    <span class="directive">public</span> <span class="type">void</span> interpret(<span class="predefined-type">Context</span> ctx) {
        <span class="comment">//递归调用每一个组成部分的interpret()方法</span>
        <span class="comment">//在递归调用时指定组成部分的连接方式，即非终结符的功能</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了上述用于表示表达式的类以外，通常在解释器模式中还提供了一个环境类Context，用于存储一些全局信息，通常在Context中包含了一个HashMap或ArrayList等类型的集合对象（也可以直接由HashMap等集合类充当环境类），存储一系列公共信息，如变量名与值的映射关系（key/value）等，用于在进行具体的解释操作时从中获取相关信息。其典型代码片段如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Context</span> {
    <span class="directive">private</span> <span class="predefined-type">HashMap</span> map = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>();
    <span class="directive">public</span> <span class="type">void</span> assign(<span class="predefined-type">String</span> key, <span class="predefined-type">String</span> value)
    {
        <span class="comment">//往环境类中设值</span>
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> lookup(<span class="predefined-type">String</span> key)
    {
        <span class="comment">//获取存储在环境类中的值</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当系统无须提供全局公共信息时可以省略环境类，可根据实际情况决定是否需要环境类。</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
绘制加法/减法解释器的类图并编写核心实现代码。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_完整解决方案">完整解决方案</h3>
<div class="paragraph">
<p>为了能够解释机器人控制指令，Sunny软件公司开发人员使用解释器模式来设计和实现机器人控制程序。针对五条文法规则，分别提供五个类来实现，其中终结符表达式direction、action和distance对应DirectionNode类、ActionNode类和DistanceNode类，非终结符表达式expression和composite对应SentenceNode类和AndNode类。</p>
</div>
<div class="paragraph">
<p>我们可以通过抽象语法树来表示具体解释过程，例如机器人控制指令“down run 10 and left move 20”对应的抽象语法树如图18-4所示：</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/机器人控制程序抽象语法树实例.jpg" alt="机器人控制程序抽象语法树实例">
</div>
</div>
<div class="paragraph">
<p>机器人控制程序实例基本结构如图18-5所示：</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/机器人控制程序结构图.jpg" alt="机器人控制程序结构图">
</div>
</div>
<div class="paragraph">
<p>在图18-5中，AbstractNode充当抽象表达式角色，DirectionNode、ActionNode和DistanceNode充当终结符表达式角色，AndNode和SentenceNode充当非终结符表达式角色。完整代码如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//注：本实例对机器人控制指令的输出结果进行模拟，将英文指令翻译为中文指令，实际情况是调用不同的控制程序进行机器人的控制，包括对移动方向、方式和距离的控制等</span>
<span class="keyword">import</span> <span class="include">java.util</span>.*;

<span class="comment">//抽象表达式</span>
<span class="directive">abstract</span> <span class="type">class</span> <span class="class">AbstractNode</span>
{
    <span class="directive">public</span> <span class="directive">abstract</span> <span class="predefined-type">String</span> interpret();
}

<span class="comment">//And解释：非终结符表达式</span>
<span class="type">class</span> <span class="class">AndNode</span> <span class="directive">extends</span> AbstractNode
{
    <span class="directive">private</span> AbstractNode left; <span class="comment">//And的左表达式</span>
    <span class="directive">private</span> AbstractNode right; <span class="comment">//And的右表达式</span>

    <span class="directive">public</span> AndNode(AbstractNode left, AbstractNode right)
    {
        <span class="local-variable">this</span>.left = left;
        <span class="local-variable">this</span>.right = right;
    }

    <span class="comment">//And表达式解释操作</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> interpret()
    {
        <span class="keyword">return</span> left.interpret() + <span class="string"><span class="delimiter">&quot;</span><span class="content">再</span><span class="delimiter">&quot;</span></span> + right.interpret();
    }
}

<span class="comment">//简单句子解释：非终结符表达式</span>
<span class="type">class</span> <span class="class">SentenceNode</span> <span class="directive">extends</span> AbstractNode
{
    <span class="directive">private</span> AbstractNode direction;
    <span class="directive">private</span> AbstractNode action;
    <span class="directive">private</span> AbstractNode distance;

    <span class="directive">public</span> SentenceNode(AbstractNode direction,AbstractNode action,AbstractNode distance)
    {
        <span class="local-variable">this</span>.direction = direction;
        <span class="local-variable">this</span>.action = action;
        <span class="local-variable">this</span>.distance = distance;
    }

    <span class="comment">//简单句子的解释操作</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> interpret()
    {
        <span class="keyword">return</span> direction.interpret() + action.interpret() + distance.interpret();
    }
}

<span class="comment">//方向解释：终结符表达式</span>
<span class="type">class</span> <span class="class">DirectionNode</span> <span class="directive">extends</span> AbstractNode
{
    <span class="directive">private</span> <span class="predefined-type">String</span> direction;

    <span class="directive">public</span> DirectionNode(<span class="predefined-type">String</span> direction)
    {
        <span class="local-variable">this</span>.direction = direction;
    }

    <span class="comment">//方向表达式的解释操作</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> interpret()
    {
        <span class="keyword">if</span> (direction.equalsIgnoreCase(<span class="string"><span class="delimiter">&quot;</span><span class="content">up</span><span class="delimiter">&quot;</span></span>))
        {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">向上</span><span class="delimiter">&quot;</span></span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (direction.equalsIgnoreCase(<span class="string"><span class="delimiter">&quot;</span><span class="content">down</span><span class="delimiter">&quot;</span></span>))
        {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">向下</span><span class="delimiter">&quot;</span></span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (direction.equalsIgnoreCase(<span class="string"><span class="delimiter">&quot;</span><span class="content">left</span><span class="delimiter">&quot;</span></span>))
        {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">向左</span><span class="delimiter">&quot;</span></span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (direction.equalsIgnoreCase(<span class="string"><span class="delimiter">&quot;</span><span class="content">right</span><span class="delimiter">&quot;</span></span>))
        {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">向右</span><span class="delimiter">&quot;</span></span>;
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">无效指令</span><span class="delimiter">&quot;</span></span>;
        }
    }
}

<span class="comment">//动作解释：终结符表达式</span>
<span class="type">class</span> <span class="class">ActionNode</span> <span class="directive">extends</span> AbstractNode
{
    <span class="directive">private</span> <span class="predefined-type">String</span> action;

    <span class="directive">public</span> ActionNode(<span class="predefined-type">String</span> action)
    {
        <span class="local-variable">this</span>.action = action;
    }

    <span class="comment">//动作（移动方式）表达式的解释操作</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> interpret()
    {
        <span class="keyword">if</span> (action.equalsIgnoreCase(<span class="string"><span class="delimiter">&quot;</span><span class="content">move</span><span class="delimiter">&quot;</span></span>))
        {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">移动</span><span class="delimiter">&quot;</span></span>;
        }
        <span class="keyword">else</span> <span class="keyword">if</span> (action.equalsIgnoreCase(<span class="string"><span class="delimiter">&quot;</span><span class="content">run</span><span class="delimiter">&quot;</span></span>))
        {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">快速移动</span><span class="delimiter">&quot;</span></span>;
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">return</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">无效指令</span><span class="delimiter">&quot;</span></span>;
        }
    }
}

<span class="comment">//距离解释：终结符表达式</span>
<span class="type">class</span> <span class="class">DistanceNode</span> <span class="directive">extends</span> AbstractNode
{
    <span class="directive">private</span> <span class="predefined-type">String</span> distance;

    <span class="directive">public</span> DistanceNode(<span class="predefined-type">String</span> distance)
    {
        <span class="local-variable">this</span>.distance = distance;
    }

<span class="comment">//距离表达式的解释操作</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> interpret()
    {
        <span class="keyword">return</span> <span class="local-variable">this</span>.distance;
    }
}

<span class="comment">//指令处理类：工具类</span>
<span class="type">class</span> <span class="class">InstructionHandler</span>
{
    <span class="directive">private</span> <span class="predefined-type">String</span> instruction;
    <span class="directive">private</span> AbstractNode node;

    <span class="directive">public</span> <span class="type">void</span> handle(<span class="predefined-type">String</span> instruction)
    {
        AbstractNode left = , right = ;
        AbstractNode direction = , action = , distance = ;
        <span class="predefined-type">Stack</span> stack = <span class="keyword">new</span> <span class="predefined-type">Stack</span>(); <span class="comment">//声明一个栈对象用于存储抽象语法树</span>
        <span class="predefined-type">String</span><span class="type">[]</span> words = instruction.split(<span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span>); <span class="comment">//以空格分隔指令字符串</span>
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; words.length; i++)
        {
            <span class="comment">//本实例采用栈的方式来处理指令，如果遇到“and”，则将其后的三个单词作为三个终结符表达式连成一个简单句子SentenceNode作为“and”的右表达式，而将从栈顶弹出的表达式作为“and”的左表达式，最后将新的“and”表达式压入栈中。</span>
            <span class="keyword">if</span> (words[i].equalsIgnoreCase(<span class="string"><span class="delimiter">&quot;</span><span class="content">and</span><span class="delimiter">&quot;</span></span>))
            {
                left = (AbstractNode)stack.pop(); <span class="comment">//弹出栈顶表达式作为左表达式</span>
                <span class="predefined-type">String</span> word1= words[++i];
                direction = <span class="keyword">new</span> DirectionNode(word1);
                <span class="predefined-type">String</span> word2 = words[++i];
                action = <span class="keyword">new</span> ActionNode(word2);
                <span class="predefined-type">String</span> word3 = words[++i];
                distance = <span class="keyword">new</span> DistanceNode(word3);
                right = <span class="keyword">new</span> SentenceNode(direction,action,distance); <span class="comment">//右表达式</span>
                stack.push(<span class="keyword">new</span> AndNode(left,right)); <span class="comment">//将新表达式压入栈中</span>
            }
            <span class="comment">//如果是从头开始进行解释，则将前三个单词组成一个简单句子SentenceNode并将该句子压入栈中</span>
            <span class="keyword">else</span>
            {
                <span class="predefined-type">String</span> word1 = words[i];
                direction = <span class="keyword">new</span> DirectionNode(word1);
                <span class="predefined-type">String</span> word2 = words[++i];
                action = <span class="keyword">new</span> ActionNode(word2);
                <span class="predefined-type">String</span> word3 = words[++i];
                distance = <span class="keyword">new</span> DistanceNode(word3);
                left = <span class="keyword">new</span> SentenceNode(direction,action,distance);
                stack.push(left); <span class="comment">//将新表达式压入栈中</span>
            }
        }
        <span class="local-variable">this</span>.node = (AbstractNode)stack.pop(); <span class="comment">//将全部表达式从栈中弹出</span>
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> output()
    {
        <span class="predefined-type">String</span> result = node.interpret(); <span class="comment">//解释表达式</span>
        <span class="keyword">return</span> result;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>工具类InstructionHandler用于对输入指令进行处理，将输入指令分割为字符串数组，将第1个、第2个和第3个单词组合成一个句子，并存入栈中；如果发现有单词“and”，则将“and”后的第1个、第2个和第3个单词组合成一个新的句子作为“and”的右表达式，并从栈中取出原先所存句子作为左表达式，然后组合成一个And节点存入栈中。依此类推，直到整个指令解析结束。</p>
</div>
<div class="paragraph">
<p>编写如下客户端测试代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Client</span>
{
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span> args<span class="type">[]</span>)
    {
        <span class="predefined-type">String</span> instruction = <span class="string"><span class="delimiter">&quot;</span><span class="content">up move 5 and down run 10 and left move 5</span><span class="delimiter">&quot;</span></span>;
        InstructionHandler handler = <span class="keyword">new</span> InstructionHandler();
        handler.handle(instruction);
        <span class="predefined-type">String</span> outString;
        outString = handler.output();
        <span class="predefined-type">System</span>.out.println(outString);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>编译并运行程序，输出结果如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>向上移动5再向下快速移动10再向左移动5</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_再谈context的作用">再谈Context的作用</h3>
<div class="paragraph">
<p>在解释器模式中，环境类Context用于存储解释器之外的一些全局信息，它通常作为参数被传递到所有表达式的解释方法interpret()中，可以在Context对象中存储和访问表达式解释器的状态，向表达式解释器提供一些全局的、公共的数据，此外还可以在Context中增加一些所有表达式解释器都共有的功能，减轻解释器的职责。</p>
</div>
<div class="paragraph">
<p>在上面的机器人控制程序实例中，我们省略了环境类角色，下面再通过一个简单实例来说明环境类的用途：</p>
</div>
<div class="paragraph">
<p>Sunny软件公司开发了一套简单的基于字符界面的格式化指令，可以根据输入的指令在字符界面中输出一些格式化内容，例如输入“LOOP 2 PRINT杨过 SPACE SPACE PRINT 小龙女 BREAK END PRINT郭靖 SPACE SPACE PRINT 黄蓉”，将输出如下结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>杨过 小龙女
杨过 小龙女
郭靖 黄蓉</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中关键词LOOP表示“循环”，后面的数字表示循环次数；PRINT表示“打印”，后面的字符串表示打印的内容；SPACE表示“空格”；BREAK表示“换行”；END表示“循环结束”。每一个关键词对应一条命令，计算机程序将根据关键词执行相应的处理操作。</p>
</div>
<div class="paragraph">
<p>现使用解释器模式设计并实现该格式化指令的解释，对指令进行分析并调用相应的操作执行指令中每一条命令。</p>
</div>
<div class="paragraph">
<p>Sunny软件公司开发人员通过分析，根据该格式化指令中句子的组成，定义了如下文法规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>expression ::= command* //表达式，一个表达式包含多条命令
command ::= loop | primitive //语句命令
loop ::= 'loopnumber' expression  'end' //循环命令，其中number为自然数
primitive ::= 'printstring'  | 'space' | 'break' //基本命令，其中string为字符串</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据以上文法规则，通过进一步分析，绘制如图18-6所示结构图：</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="./images/格式化指令结构图.jpg" alt="格式化指令结构图">
</div>
</div>
<div class="paragraph">
<p>在图18-6中，Context充当环境角色，Node充当抽象表达式角色，ExpressionNode、CommandNode和LoopCommandNode充当非终结符表达式角色，PrimitiveCommandNode充当终结符表达式角色。完整代码如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.util</span>.*;

<span class="comment">//环境类：用于存储和操作需要解释的语句，在本实例中每一个需要解释的单词可以称为一个动作标记(Action Token)或命令</span>
<span class="type">class</span> <span class="class">Context</span>
{
    <span class="directive">private</span> <span class="predefined-type">StringTokenizer</span> tokenizer; <span class="comment">//StringTokenizer类，用于将字符串分解为更小的字符串标记(Token)，默认情况下以空格作为分隔符</span>
    <span class="directive">private</span> <span class="predefined-type">String</span> currentToken; <span class="comment">//当前字符串标记</span>

    <span class="directive">public</span> <span class="predefined-type">Context</span>(<span class="predefined-type">String</span> text)
    {
        tokenizer = <span class="keyword">new</span> <span class="predefined-type">StringTokenizer</span>(text); <span class="comment">//通过传入的指令字符串创建StringTokenizer对象</span>
        nextToken();
    }

    <span class="comment">//返回下一个标记</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> nextToken()
    {
        <span class="keyword">if</span> (tokenizer.hasMoreTokens())
        {
            currentToken = tokenizer.nextToken();
        }
        <span class="keyword">else</span>
        {
            currentToken = ;
        }
        <span class="keyword">return</span> currentToken;
    }

    <span class="comment">//返回当前的标记</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> currentToken() {
        <span class="keyword">return</span> currentToken;
    }

    <span class="comment">//跳过一个标记</span>
    <span class="directive">public</span> <span class="type">void</span> skipToken(<span class="predefined-type">String</span> token)
    {
        <span class="keyword">if</span> (!token.equals(currentToken))
        {
            <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">错误提示：</span><span class="delimiter">&quot;</span></span> + currentToken + <span class="string"><span class="delimiter">&quot;</span><span class="content">解释错误！</span><span class="delimiter">&quot;</span></span>);
        }
        nextToken();
    }

    <span class="comment">//如果当前的标记是一个数字，则返回对应的数值</span>
    <span class="directive">public</span> <span class="type">int</span> currentNumber()
    {
        <span class="type">int</span> number = <span class="integer">0</span>;
        <span class="keyword">try</span>
        {
            number = <span class="predefined-type">Integer</span>.parseInt(currentToken); <span class="comment">//将字符串转换为整数</span>
        }
        <span class="keyword">catch</span>(<span class="exception">NumberFormatException</span> e)
        {
            <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">错误提示：</span><span class="delimiter">&quot;</span></span> + e);
        }
        <span class="keyword">return</span> number;
    }
}

<span class="comment">//抽象节点类：抽象表达式</span>
<span class="directive">abstract</span> <span class="type">class</span> <span class="class">Node</span>
{
    <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">void</span> interpret(<span class="predefined-type">Context</span> text); <span class="comment">//声明一个方法用于解释语句</span>
    <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">void</span> execute(); <span class="comment">//声明一个方法用于执行标记对应的命令</span>
}

<span class="comment">//表达式节点类：非终结符表达式</span>
<span class="type">class</span> <span class="class">ExpressionNode</span> <span class="directive">extends</span> Node
{
    <span class="directive">private</span> <span class="predefined-type">ArrayList</span>&lt;Node&gt; list = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;Node&gt;(); <span class="comment">//定义一个集合用于存储多条命令</span>

    <span class="directive">public</span> <span class="type">void</span> interpret(<span class="predefined-type">Context</span> context)
    {
        <span class="comment">//循环处理Context中的标记</span>
        <span class="keyword">while</span> (<span class="predefined-constant">true</span>)
        {
            <span class="comment">//如果已经没有任何标记，则退出解释</span>
            <span class="keyword">if</span> (context.currentToken() == )
            {
                <span class="keyword">break</span>;
            }
            <span class="comment">//如果标记为END，则不解释END并结束本次解释过程，可以继续之后的解释</span>
            <span class="keyword">else</span> <span class="keyword">if</span> (context.currentToken().equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">END</span><span class="delimiter">&quot;</span></span>))
            {
                context.skipToken(<span class="string"><span class="delimiter">&quot;</span><span class="content">END</span><span class="delimiter">&quot;</span></span>);
                <span class="keyword">break</span>;
            }
            <span class="comment">//如果为其他标记，则解释标记并将其加入命令集合</span>
            <span class="keyword">else</span>
            {
                Node commandNode = <span class="keyword">new</span> CommandNode();
                commandNode.interpret(context);
                list.add(commandNode);
            }
        }
    }

    <span class="comment">//循环执行命令集合中的每一条命令</span>
    <span class="directive">public</span> <span class="type">void</span> execute()
    {
        <span class="predefined-type">Iterator</span> iterator = list.iterator();
        <span class="keyword">while</span> (iterator.hasNext())
        {
            ((Node)iterator.next()).execute();
        }
    }
}

<span class="comment">//语句命令节点类：非终结符表达式</span>
<span class="type">class</span> <span class="class">CommandNode</span> <span class="directive">extends</span> Node
{
    <span class="directive">private</span> Node node;

    <span class="directive">public</span> <span class="type">void</span> interpret(<span class="predefined-type">Context</span> context)
    {
        <span class="comment">//处理LOOP循环命令</span>
        <span class="keyword">if</span> (context.currentToken().equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">LOOP</span><span class="delimiter">&quot;</span></span>))
        {
            node = <span class="keyword">new</span> LoopCommandNode();
            node.interpret(context);
        }
        <span class="comment">//处理其他基本命令</span>
        <span class="keyword">else</span>
        {
            node = <span class="keyword">new</span> PrimitiveCommandNode();
            node.interpret(context);
        }
    }

    <span class="directive">public</span> <span class="type">void</span> execute()
    {
        node.execute();
    }
}

<span class="comment">//循环命令节点类：非终结符表达式</span>
<span class="type">class</span> <span class="class">LoopCommandNode</span> <span class="directive">extends</span> Node
{
    <span class="directive">private</span> <span class="type">int</span> number; <span class="comment">//循环次数</span>
    <span class="directive">private</span> Node commandNode; <span class="comment">//循环语句中的表达式</span>

    <span class="comment">//解释循环命令</span>
    <span class="directive">public</span> <span class="type">void</span> interpret(<span class="predefined-type">Context</span> context)
    {
        context.skipToken(<span class="string"><span class="delimiter">&quot;</span><span class="content">LOOP</span><span class="delimiter">&quot;</span></span>);
        number = context.currentNumber();
        context.nextToken();
        commandNode = <span class="keyword">new</span> ExpressionNode(); <span class="comment">//循环语句中的表达式</span>
        commandNode.interpret(context);
    }

    <span class="directive">public</span> <span class="type">void</span> execute()
    {
        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="integer">0</span>;i&lt;number;i++)
            commandNode.execute();
    }
}

<span class="comment">//基本命令节点类：终结符表达式</span>
<span class="type">class</span> <span class="class">PrimitiveCommandNode</span> <span class="directive">extends</span> Node
{
    <span class="directive">private</span> <span class="predefined-type">String</span> name;
    <span class="directive">private</span> <span class="predefined-type">String</span> text;

    <span class="comment">//解释基本命令</span>
    <span class="directive">public</span> <span class="type">void</span> interpret(<span class="predefined-type">Context</span> context)
    {
        name = context.currentToken();
        context.skipToken(name);
        <span class="keyword">if</span> (!name.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">PRINT</span><span class="delimiter">&quot;</span></span>) &amp;&amp; !name.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">BREAK</span><span class="delimiter">&quot;</span></span>) &amp;&amp; !name.equals (<span class="string"><span class="delimiter">&quot;</span><span class="content">SPACE</span><span class="delimiter">&quot;</span></span>))
        {
            <span class="predefined-type">System</span>.err.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">非法命令！</span><span class="delimiter">&quot;</span></span>);
        }
        <span class="keyword">if</span> (name.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">PRINT</span><span class="delimiter">&quot;</span></span>))
        {
            text = context.currentToken();
            context.nextToken();
        }
    }

    <span class="directive">public</span> <span class="type">void</span> execute()
    {
        <span class="keyword">if</span> (name.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">PRINT</span><span class="delimiter">&quot;</span></span>))
            <span class="predefined-type">System</span>.out.print(text);
        <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">SPACE</span><span class="delimiter">&quot;</span></span>))
            <span class="predefined-type">System</span>.out.print(<span class="string"><span class="delimiter">&quot;</span><span class="content"> </span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">BREAK</span><span class="delimiter">&quot;</span></span>))
            <span class="predefined-type">System</span>.out.println();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在本实例代码中，环境类Context类似一个工具类，它提供了用于处理指令的方法，如nextToken()、currentToken()、skipToken()等，同时它存储了需要解释的指令并记录了每一次解释的当前标记(Token)，而具体的解释过程交给表达式解释器类来处理。我们还可以将各种解释器类包含的公共方法移至环境类中，更好地实现这些方法的重用和扩展。</p>
</div>
<div class="paragraph">
<p>针对本实例代码，我们编写如下客户端测试代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Client</span>
{
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args)
    {
        <span class="predefined-type">String</span> text = <span class="string"><span class="delimiter">&quot;</span><span class="content">LOOP 2 PRINT 杨过 SPACE SPACE PRINT 小龙女 BREAK END PRINT 郭靖 SPACE SPACE PRINT 黄蓉</span><span class="delimiter">&quot;</span></span>;
        <span class="predefined-type">Context</span> context = <span class="keyword">new</span> <span class="predefined-type">Context</span>(text);

        Node node = <span class="keyword">new</span> ExpressionNode();
        node.interpret(context);
        node.execute();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>编译并运行程序，输出结果如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>杨过 小龙女
杨过 小龙女
郭靖 黄蓉</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
预测指令“LOOP 2 LOOP 2 PRINT杨过 SPACE SPACE PRINT 小龙女 BREAK END PRINT 郭靖 SPACE SPACE PRINT 黄蓉 BREAK END”的输出结果。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_解释器模式总结">解释器模式总结</h3>
<div class="paragraph">
<p>解释器模式为自定义语言的设计和实现提供了一种解决方案，它用于定义一组文法规则并通过这组文法规则来解释语言中的句子。虽然解释器模式的使用频率不是特别高，但是它在正则表达式、XML文档解释等领域还是得到了广泛使用。与解释器模式类似，目前还诞生了很多基于抽象语法树的源代码处理工具，例如Eclipse中的Eclipse AST，它可以用于表示Java语言的语法结构，用户可以通过扩展其功能，创建自己的文法规则。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>主要优点</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>解释器模式的主要优点如下：</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</p>
</li>
<li>
<p>每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。</p>
</li>
<li>
<p>实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。</p>
</li>
<li>
<p>增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。</p>
</li>
</ol>
</div>
</div>
</div>
</li>
<li>
<p>主要缺点</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>解释器模式的主要缺点如下：</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。</p>
</li>
<li>
<p>执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。</p>
</li>
</ol>
</div>
</div>
</div>
</li>
<li>
<p>适用场景</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>在以下情况下可以考虑使用解释器模式：</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。</p>
</li>
<li>
<p>一些重复出现的问题可以用一种简单的语言来进行表达。</p>
</li>
<li>
<p>一个语言的文法较为简单。</p>
</li>
<li>
<p>执行效率不是关键问题。【注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。】</p>
</li>
</ol>
</div>
</div>
</div>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Sunny软件公司欲为数据库备份和同步开发一套简单的数据库同步指令，通过指令可以对数据库中的数据和结构进行备份，例如，输入指令“COPY VIEW FROM srcDB TO desDB”表示将数据库srcDB中的所有视图(View)对象都拷贝至数据库desDB；输入指令“MOVE TABLE Student FROM srcDB TO desDB”表示将数据库srcDB中的Student表移动至数据库desDB。试使用解释器模式来设计并实现该数据库同步指令。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>yobyzal </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://yobyzal.github.io/2019/16-interpreter-pattern/>https://yobyzal.github.io/2019/16-interpreter-pattern/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://yobyzal.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
                    #设计模式</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://yobyzal.github.io/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://yobyzal.github.io/2019/17-iterator-pattern/" class="prev" rel="prev" title="17 - 迭代器模式"><i class="iconfont icon-left"></i>&nbsp;17 - 迭代器模式</a>
         
        
        <a href="https://yobyzal.github.io/2019/15-command-pattern/" class="next" rel="next" title="15 - 命令模式">15 - 命令模式&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2019 - 2019</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://yobyzal.github.io/">yobyzal</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>
