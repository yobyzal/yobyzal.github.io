<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on yobyzal的网络笔记</title>
    <link>https://yobyzal.github.io/posts/</link>
    <description>Recent content in Posts on yobyzal的网络笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 03 Sep 2019 08:24:57 +0800</lastBuildDate>
    
	<atom:link href="https://yobyzal.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How to Assign Multiple Ip Addresses to Single Network Card in Linux</title>
      <link>https://yobyzal.github.io/posts/how-to-assign-multiple-ip-addresses-to-single-network-card-in-linux/</link>
      <pubDate>Tue, 03 Sep 2019 08:24:57 +0800</pubDate>
      
      <guid>https://yobyzal.github.io/posts/how-to-assign-multiple-ip-addresses-to-single-network-card-in-linux/</guid>
      <description>转载自：How To Assign Multiple IP Addresses To Single Network Card In Linux
 Some of you might wondering why would we assign multiple IP addresses to single Network card. There can be many reasons. Say for example, you are doing some testing on your Linux box that requires two or more network cards. Would you buy new one? No, It is not necessary! You can set multiple IP series, for example 192.</description>
    </item>
    
    <item>
      <title>编写 &#34;ViewModelBase&#34; in MVVM (WPF)</title>
      <link>https://yobyzal.github.io/posts/how-to-write-viewmodelbase/</link>
      <pubDate>Mon, 02 Sep 2019 16:34:24 +0800</pubDate>
      
      <guid>https://yobyzal.github.io/posts/how-to-write-viewmodelbase/</guid>
      <description>这篇博文记录如何编写 MVVM 模式中 ViewModelBase 类。
 ViewModelBase 类是所有视图模型的基类，可以包含一些通用逻辑； ViewModelBase 类需要继承 INotifyPropertyChanged 接口以便通知视图做出变更；
public abstract class ViewModelBase : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } }   代码中，[CallerMemberName] 特性使方法调用更加简单，只需要写明 OnPropertyChanged() 即可。如果不使用这个特性，就需要写成以下两种形式之一：
 填入字符串形式的属性名 OnPropertyChanged(&amp;quot;SomeProperty&amp;quot;) 这种形式下如果属性名写错了，IDE是不会报错的，运行起来也不会达到我们想要的结果； 使用 lambda 表达式，OnPropertyChanged(() =&amp;gt; SomeProperty) 使用 nameof(SomeProperty)  以上两种方式都不如使用 [CallerMemberName] 写起来方便，举个例子：
public string FirstName { get { return _firstName; } set { _firtName = value; OnPropertyChanged(); // 使用 [CallerMemberName] // OnPropertyChanged(&amp;quot;FirstName&amp;quot;) // OnPropertyChanged(() =&amp;gt; FirstName) // OnPropertyChanged(nameof(FirstName)) } }  有了 ref 关键词后，还可以写成下面这种形式：</description>
    </item>
    
  </channel>
</rss>